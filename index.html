<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Cursor: AI-Powered Coding & MCP</title>

		<!-- Google Fonts -->
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;500;600;700&display=swap" rel="stylesheet">

		<!-- Core Reveal.js styles -->
		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/sky.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
		
		<!-- Custom styles -->
		<link rel="stylesheet" href="custom/custom-styles.css">
		
		<!-- HTTPS redirect and presenter info script -->
		<script src="custom/custom-scripts.js"></script>
		
		<!-- Mermaid Plugin -->
		<script src="https://cdn.jsdelivr.net/npm/reveal.js-mermaid-plugin@11.4.1/plugin/mermaid/mermaid.js"></script>
	</head>
	<body>
		<div class="reveal"">
			<div class="slides">
				<!-- 1. Title Slide -->
				<section data-background="resources/images/cursor-website.png" data-background-opacity="1" data-background-size="cover">
					<div style="height: 100px;"></div>
					<div style="background-color: rgba(232, 247, 251, 0.9); padding: 30px; border-radius: 10px; max-width: 90%; margin: 0 auto;">
						<h1><strong>Cursor & Model Context Protocol</strong></h1>
						<h3>AI-Powered Coding for Enhanced Productivity</h3>
						<p class="author-info">
							<span class="presenter-name" style="font-size: 1.2em;"></span><br>
							<span style="font-weight: 500;">Team:</span> ðŸ˜ˆ<span class="presenter-dept" style="font-style: normal;"></span>ðŸ”¥<br>
							<span class="presenter-univ" style="text-decoration: underline;"></span>
						</p>
						<p class="smalltext">Today: <span class="presentation-date"></span></p>
						<p class="smalltext">Session: <span class="session-name"></p>
					</div>
					<aside class="notes">
						Welcome to this presentation on Cursor, the AI-powered code editor, and the Model Context Protocol. We'll explore how these technologies are transforming the coding experience.
					</aside>
				</section>

				<!-- Table of Contents slide -->
				<section>
					<h2 class="bg-header">Presentation Outline</h2>
					<ol>
						<li><a href="#/2"><strong>Introduction to Cursor</strong></a> - AI-powered code editor</li>
						<li><a href="#/3"><strong>Cursor Key Features</strong></a> - Agent, Chat, Tab, and more</li>
							<ul style="font-size: 0.85em; margin-top: 5px;">
								<li><a href="#/7"><strong>Codebase Indexing</strong></a> - How Cursor understands your code</li>
							</ul>
						<li><a href="#/8"><strong>Model Context Protocol</strong></a> - Understanding MCP architecture</li>
						<li><a href="#/12"><strong>MCP Implementation</strong></a> - Building with MCP</li>
						<li><a href="#/16"><strong>Practical Applications</strong></a> - Real-world use cases</li>
						<li><a href="#/17"><strong>Discussion</strong></a> - Q&A and exercises</li>
					</ol>
					<aside class="notes">
						This is our roadmap for today's session. We'll start with an introduction to Cursor, explore its key features including codebase indexing, understand the Model Context Protocol, look at implementation details, examine practical applications, and finish with a discussion.
					</aside>
					<div class="slide-citation">Click on any section to jump directly to it</div>
				</section>

				<!-- 2. Introduction to Cursor Section -->
				<section>
					<section>
						<h2 class="bg-header">Introduction to Cursor</h2>
						<div class="container">
							<div class="col">
								<ul>
									<li>AI-powered code editor <span class="highlight">built on VSCode</span></li>
									<li>Helps developers <span class="highlight">build software faster</span></li>
									<li>Features <span class="fragment highlight-blue" data-fragment-index="1"><strong>intelligent code assistance</strong></span> powered by AI models</li>
									<li>Provides <span class="highlight">agent capabilities</span> for end-to-end tasks</li>
									<li>Integrates with <span class="highlight">Model Context Protocol</span> for extended functionality</li>
								</ul>
							</div>
							<div class="col">
								<img src="resources/images/cursor-interface.png" alt="Cursor editor interface" style="box-shadow: none!important;">
								<p class="img-caption">Cursor editor interface</p>
							</div>
						</div>
						<aside class="notes">
							Cursor is an AI-powered code editor built on VSCode that helps developers build software faster. It features intelligent code assistance powered by AI models and provides agent capabilities for end-to-end tasks.
						</aside>
					</section>
					
					<section>
						<h3>Agent Mode</h3>
						<div class="container">
							<div class="col">
								<ul>
									<li>Completes tasks <span class="highlight">end-to-end</span></li>
									<li>Works <span class="highlight">quickly</span> while keeping programmers in the loop</li>
									<li>Activated by selecting <span class="highlight">'agent'</span> in Composer</li>
									<li>Can understand complex requirements</li>
									<li>Executes multi-step coding tasks</li>
								</ul>
							</div>
							<div class="col">
								<pre><code class="javascript">
// Example of Agent handling a complex task
// User request: "Create a React component for a user profile 
// that fetches data from an API and shows loading state"

// Agent can generate complete solution like:
import React, { useState, useEffect } from 'react';
import './UserProfile.css';

const UserProfile = ({ userId }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    fetchUserData(userId);
  }, [userId]);

  const fetchUserData = async (id) => {
    try {
      const response = await fetch(`/api/users/${id}`);
      const data = await response.json();
      setUser(data);
      setLoading(false);
    } catch (err) {
      setError('Failed to load user data');
      setLoading(false);
    }
  };

  if (loading) return <div className="loading">Loading...</div>;
  if (error) return <div className="error">{error}</div>;

  return (
    <div className="user-profile">
      <h2>{user.name}</h2>
      <p>{user.email}</p>
      {/* More user details */}
    </div>
  );
};

export default UserProfile;
</code></pre>
							</div>
						</div>
						<aside class="notes">
							Agent mode is one of Cursor's most powerful features, allowing users to complete complex coding tasks from end to end while still staying in control of the process. The agent can understand requirements, generate appropriate code, and execute multi-step tasks efficiently.
						</aside>
					</section>

					<section>
						<h3>Cursor's Core Capabilities</h3>
						<table class="data-table" style="width: 87%;">
							<thead>
								<tr>
									<th>Capability</th>
									<th>Description</th>
									<th>Benefits</th>
									<th>Activation Method</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>Agent</td>
									<td class="highlight-cell">Completes tasks end-to-end while keeping programmers in the loop</td>
									<td>Faster development, reduced manual work</td>
									<td>Select 'agent' in Composer</td>
								</tr>
								<tr>
									<td>Context Finding</td>
									<td class="highlight-cell">Understands codebase using custom retrieval models</td>
									<td>Reduces need for manual context addition</td>
									<td>Automatic</td>
								</tr>
								<tr>
									<td>Command Running</td>
									<td>Writes and runs terminal commands automatically</td>
									<td>Improved workflow efficiency</td>
									<td>Requires user confirmation by default</td>
								</tr>
								<tr>
									<td>Error Handling</td>
									<td class="highlight-cell">Detects and applies fixes for lint errors</td>
									<td>Reduced debugging time</td>
									<td>Automatic</td>
								</tr>
								<tr>
									<td>Tab Autocomplete</td>
									<td>Predicts and suggests next edits across multiple lines</td>
									<td>Increased coding speed</td>
									<td>Always on once enabled</td>
								</tr>
							</tbody>
						</table>
						<p class="img-caption">Cursor's core capabilities and benefits</p>
						<div class="slide-citation">
							Source: https://www.cursor.com/features
						</div>
						<aside class="notes">
							Cursor offers several core capabilities including Agent mode for end-to-end task completion, Context Finding for codebase understanding, Command Running for automatic terminal operations, Error Handling for automatic lint error fixing, and Tab Autocomplete for predictive code editing.
						</aside>
					</section>
				</section>

				<!-- 3. Cursor Key Features Section -->
				<section>
					<section>
						<h2 class="bg-header">Cursor Key Features</h2>
						<div class="container">
							<div class="col">
								<ul>
									<li><span class="highlight">Agent Mode</span> - Completes coding tasks end-to-end</li>
									<li><span class="highlight">Chat</span> - AI-powered chat that understands your codebase</li>
									<li><span class="highlight">Tab</span> - Smart code autocomplete with multi-line predictions</li>
									<li><span class="highlight">Ctrl+K</span> - Edit and generate code with AI assistance</li>
								</ul>
							</div>
							<div class="col">
								<img src="resources/images/cursor-feature.png" alt="Cursor features overview" style="max-height: 450px;">
								<p class="img-caption">Cursor features overview</p>
							</div>
						</div>
						<aside class="notes">
							Cursor's key features include Agent Mode for end-to-end task completion, Chat for AI-powered code assistance, Tab for smart code autocomplete, and Ctrl+K for AI-assisted code editing and generation.
						</aside>
					</section>
					
					<section>
						<h3>Chat with Codebase</h3>
						<div class="container">
							<div class="col">
								<ul>
									<li>AI chat that <span class="highlight">sees your codebase</span></li>
									<li>Always sees current file and cursor position</li>
									<li>Add code blocks with <span class="highlight">Ctrl+Shift+L</span> or <span class="highlight">@</span></li>
									<li>Chat with entire codebase using <span class="highlight">Ctrl+Enter</span></li>
									<li>Instantly apply code suggestions with the play button</li>
									<li>Use <span class="highlight">@Codebase</span> for searching relevant code</li>
								</ul>
							</div>
							<div class="col">
								<img src="resources/images/cursor-mode.png" alt="Cursor Chat Interface">
								<p class="img-caption">Cursor Chat Interface</p>
							</div>
						</div>
						<aside class="notes">
							Cursor's Chat feature provides an AI assistant that can see your codebase, making it much more context-aware than generic AI assistants. It understands the current file you're working on and where your cursor is positioned, which enables it to give much more relevant advice and code suggestions.
						</aside>
					</section>

					<section>
						<h3>Codebase Indexing</h3>
						<div class="container">
							<div class="col">
								<ul>
									<li><span class="highlight">Local-first scan</span> â€“ builds a Merkle-tree of your files (respects .gitignore/.cursorignore)</li>
									<li><span class="highlight">Incremental updates</span> â€“ every 10 minutes it diff-checks and only uploads changed chunks</li>
									<li><span class="highlight">Vector embeddings</span> â€“ files split into overlapping snippets and embedded server-side (with obfuscated paths)</li>
									<li><span class="highlight">On-demand retrieval</span> â€“ queries return only chunk IDs; Cursor reads the matching lines locally before prompting the LLM</li>
								</ul>
							</div>
							<div class="col">
								<video src="resources/videos/Codebase-understadning.mov" width="600" height="400" ></video>
							</div>
						</div>
						<div class="slide-citation">
							Source: <a href="https://www.cursor.com/security#codebase-indexing" target="_blank">https://www.cursor.com/security#codebase-indexing</a>
						</div>
						<aside class="notes">
							Cursor's indexing engine lets you work on massive repos without re-uploading everything. By hashing and diffing locally, uploading only deltas, and storing hashed embeddings with obfuscated paths, it delivers sub-second code search and context for AI promptsâ€”while ensuring your source code never leaks in full.
						</aside>
					</section>

					<section>
						<h3>Tab Completion</h3>
						<div class="container">
							<div class="col">
								<ul>
									<li>Powerful autocomplete that <span class="highlight">predicts your next edit</span></li>
									<li>Always on after enabling</li>
									<li>Suggests edits <span class="highlight">across multiple lines</span></li>
									<li>Takes into account your <span class="highlight">recent changes</span></li>
									<li>Provides smart rewrites to fix mistakes</li>
									<li>Predicts next cursor position for seamless navigation</li>
								</ul>
							</div>
							<div class="col">
								<img src="resources/images/cursor-tab.png" alt="Cursor Tab Completion">
								<p class="img-caption">Tab completion suggesting multi-line edits</p>
							</div>
						</div>
						<aside class="notes">
							Cursor's Tab completion feature goes beyond traditional code completion by predicting entire blocks of code across multiple lines. It adapts to your coding style and recent changes, making suggestions more relevant and useful over time.
						</aside>
					</section>

					<section>
						<h3>Ctrl+K Editing</h3>
						<div class="container">
							<div class="col">
								<ul>
									<li>Edit and write code <span class="highlight">with AI assistance</span></li>
									<li>Select code, press <span class="highlight">Ctrl+K</span>, describe the change</li>
									<li>Generate new code by pressing Ctrl+K without selection</li>
									<li>Use in terminal for <span class="highlight">natural language commands</span></li>
									<li>"Quick Questions" feature for instant code explanations</li>
								</ul>
							</div>
							<div class="col">
								<pre><code class="javascript">
// Example of using Ctrl+K to transform code
// Selected code:
function calculateTotal(items) {
  let total = 0;
  for (let i = 0; i < items.length; i++) {
    total += items[i].price;
  }
  return total;
}

// User request with Ctrl+K: "Convert to use reduce"

// Transformed code:
function calculateTotal(items) {
  return items.reduce((total, item) => total + item.price, 0);
}
</code></pre>
							</div>
						</div>
						<aside class="notes">
							Ctrl+K is Cursor's universal shortcut for AI-assisted editing. It works contextually - when you select code and press Ctrl+K, you can describe how to change it; when you press Ctrl+K without a selection, you can generate entirely new code. The feature even works in the terminal for natural language command generation.
						</aside>
					</section>

					<section>
						<h3>Additional Features</h3>
						<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; margin-top: 20px;">
							<div>
								<h4>Reference & Documentation</h4>
								<ul>
									<li>Reference code with @ symbols</li>
									<li>Include images for visual context</li>
									<li>Search the web with @Web</li>
									<li>Reference libraries with @LibraryName</li>
								</ul>
							</div>
							<div>
								<h4>Terminal Integration</h4>
								<ul>
									<li>Terminal Ctrl+K for natural language commands</li>
									<li>Automatic command running (with approval)</li>
									<li>Error detection and fixing</li>
								</ul>
							</div>
							<div>
								<h4>Code Quality</h4>
								<ul>
									<li>Automatic lint error detection</li>
									<li>Smart rewrites for mistakes</li>
									<li>Multi-line edits for consistency</li>
								</ul>
							</div>
							<div>
								<h4>Security & Customization</h4>
								<ul>
									<li>SOC 2 Certified</li>
									<li>Customizable models</li>
									<li>Ignore files for sensitive data</li>
								</ul>
							</div>
						</div>
						<div class="slide-citation">
							Source: https://www.cursor.com/features
						</div>
						<aside class="notes">
							Cursor includes many additional productivity features that enhance the coding experience. These include powerful reference capabilities, terminal integration, code quality tools, and important security and customization options to fit different development needs.
						</aside>
					</section>
				</section>

				<!-- 4. Model Context Protocol Section -->
				<section>
					<section>
						<h2 class="bg-header">Model Context Protocol</h2>
						<h3>Understanding MCP Architecture</h3>
						<div class="container">
							<div class="col">
								<ul>
									<li><span class="highlight">Open protocol</span> that standardizes how applications provide context to LLMs</li>
									<li>Acts like a <span class="highlight">USB-C port for AI</span> applications</li>
									<li>Connects AI models to <span class="fragment highlight-blue" data-fragment-index="1"><strong>data sources and tools</strong></span></li>
									<li>Enables <span class="highlight">switching between LLM providers</span></li>
									<li>Ensures <span class="highlight">data security</span> within your infrastructure</li>
								</ul>
							</div>
							<div class="col">
								<div class="mermaid">
									<pre>
flowchart LR
  %% Define a reusable class for consistent styling
  classDef common fill:#e0e0ff,stroke:#4b0082,stroke-width:1px,color:#000080;

  subgraph "Your Computer"
    direction TB
    client["Host with MCP Client<br>(Claude, IDEs, Tools)"]:::common

    subgraph "MCP Servers"
      direction LR
      A["MCP Server A"]:::common --> DataA[(Local Data Source A)]:::common
      B["MCP Server B"]:::common --> DataB[(Local Data Source B)]:::common
      C["MCP Server C"]:::common --> Web[(Web APIs)]:::common
    end
  end

  subgraph Internet
    Remote[(Remote Service C)]:::common
  end

  client -->|MCP Protocol| A
  client -->|MCP Protocol| B
  client -->|MCP Protocol| C

  DataA --> A
  DataB --> B
  Web   --> Remote
									</pre>
								</div>
								<p class="img-caption">MCP architecture overview</p>
							</div>
						</div>
						<aside class="notes">
							The Model Context Protocol (MCP) is an open protocol that standardizes how applications provide context to LLMs. Think of MCP like a USB-C port for AI applications - just as USB-C provides a standardized way to connect devices to peripherals, MCP provides a standardized way to connect AI models to data sources and tools.
						</aside>
					</section>

					<section>
						<h3>MCP Architecture</h3>
						<div class="container">
							<div class="col">
								<ul>
									<li><span class="highlight">MCP Hosts</span>: Programs like Cursor, Claude Desktop, or AI tools</li>
									<li><span class="highlight">MCP Clients</span>: Protocol clients with 1:1 server connections</li>
									<li><span class="highlight">MCP Servers</span>: Lightweight programs exposing capabilities</li>
									<li><span class="highlight">Data Sources</span>: Local files, databases, services</li>
									<li><span class="highlight">Remote Services</span>: External APIs and web services</li>
								</ul>
							</div>
							<div class="col">
								<div class="mermaid">
									<pre>
flowchart TD
  classDef hosts fill:#f9f9ff,stroke:#333,stroke-width:1px
  classDef clients fill:#e6f3ff,stroke:#333,stroke-width:1px
  classDef servers fill:#f0fff0,stroke:#333,stroke-width:1px
  classDef data fill:#fff0f0,stroke:#333,stroke-width:1px
  classDef remote fill:#f5f5f5,stroke:#333,stroke-width:1px
  
  Host["MCP Hosts<br>(Cursor, Claude Desktop)"]:::hosts
  Client["MCP Clients<br>(Protocol clients)"]:::clients
  Server["MCP Servers<br>(Lightweight programs)"]:::servers
  Data["Data Sources<br>(Files, DBs, Services)"]:::data
  Remote["Remote Services<br>(External APIs)"]:::remote
  
  Host --> Client
  Client --> Server
  Server --> Data
  Server --> Remote
									</pre>
								</div>
								<p class="img-caption">MCP Architecture Diagram</p>
							</div>
						</div>
						<aside class="notes">
							MCP follows a client-server architecture where a host application can connect to multiple servers. The architecture consists of MCP Hosts (programs like Cursor or Claude Desktop), MCP Clients (protocol clients with 1:1 server connections), MCP Servers (lightweight programs exposing capabilities), Local Data Sources (your computer's files, databases, and services), and Remote Services (external systems accessible over the internet).
						</aside>
					</section>	

					<section>
						<h3>MCP Transport Types</h3>
						<div class="container">
							<div class="col">
								<table class="data-table">
									<thead>
										<tr>
											<th>Feature</th>
											<th>stdio Transport</th>
											<th>SSE Transport</th>
										</tr>
									</thead>
									<tbody>
										<tr>
											<td>Hosting</td>
											<td>Local machine</td>
											<td class="highlight-cell">Local or remote</td>
										</tr>
										<tr>
											<td>Management</td>
											<td>Automatic by Cursor</td>
											<td>Manual by user</td>
										</tr>
										<tr>
											<td>Communication</td>
											<td>Direct via stdout</td>
											<td class="highlight-cell">Over network</td>
										</tr>
										<tr>
											<td>Accessibility</td>
											<td>Local only</td>
											<td class="highlight-cell">Can be shared</td>
										</tr>
										<tr>
											<td>Input format</td>
											<td>Shell command</td>
											<td>URL to /sse endpoint</td>
										</tr>
									</tbody>
								</table>
							</div>
							<div class="col">
								<pre><code class="json">
// Configuration for stdio transport
{
  "mcpServers": {
    "server-name": {
      "command": "npx",
      "args": ["-y", "mcp-server"],
      "env": {
        "API_KEY": "value"
      }
    }
  }
}

// URL for SSE transport
http://example.com:8000/sse
</code></pre>
							</div>
						</div>
						<div class="slide-citation">
							Source: https://docs.cursor.com/context/model-context-protocol
						</div>
						<aside class="notes">
							Cursor supports two transport types for MCP servers: stdio transport (runs locally, managed by Cursor, communicates via stdout, only accessible locally) and SSE transport (can run locally or remotely, managed by you, communicates over the network, can be shared). Each transport type has different use cases, with stdio being simpler for local development and SSE offering more flexibility for distributed teams.
						</aside>
					</section>

					<section>
						<h3>MCP Configuration</h3>
						<div class="container">
							<div class="col">
								<h4>Configuration Locations:</h4>
								<ul>
									<li><span class="highlight">Project Configuration</span>: <br><code>.cursor/mcp.json</code> in project directory</li>
									<li><span class="highlight">Global Configuration</span>: <br><code>~/.cursor/mcp.json</code> in home directory</li>
								</ul>
								<h4>Configuration Structure:</h4>
								<ul>
									<li><code>command</code>: The executable to run</li>
									<li><code>args</code>: Command line arguments</li>
									<li><code>env</code>: Environment variables</li>
								</ul>
							</div>
							<div class="col">
								<pre><code class="json">
// Example Project-specific MCP configuration
{
  "mcpServers": {
    "database-accessor": {
      "command": "python",
      "args": ["-m", "mcp_database_server"],
      "env": {
        "DB_CONNECTION": "postgres://user:pass@localhost/db",
        "API_KEY": "sk-xxxx"
      }
    },
    "documentation-lookup": {
      "command": "npx",
      "args": ["-y", "mcp-docs-server"],
      "env": {
        "DOCS_PATH": "./documentation"
      }
    }
  }
}
</code></pre>
							</div>
						</div>
						<div class="slide-citation">
							Source: https://docs.cursor.com/context/model-context-protocol
						</div>
						<aside class="notes">
							MCP configuration can be placed in two locations: project-specific (in a .cursor/mcp.json file in your project directory) or global (in a ~/.cursor/mcp.json file in your home directory). The configuration file uses a JSON format that specifies the command to run, its arguments, and environment variables that will be available to your MCP server process.
						</aside>
					</section>

					<section>
						<h3>Using MCP in Cursor</h3>
						<div class="container">
							<div class="col">
								<h4>Automatic Tool Usage:</h4>
								<ul>
									<li>Composer Agent <span class="highlight">automatically</span> uses relevant MCP tools</li>
									<li>Tools are listed under <span class="highlight">'Available Tools'</span> in MCP settings</li>
									<li>You can intentionally prompt tool usage by <span class="highlight">mentioning the tool</span></li>
								</ul>
							</div>
							<div class="col">
								<img src="resources/images/cursor-mcp.png" alt="MCP Tool Usage in Cursor">
								<p class="img-caption">MCP Tool Settings in Cursor</p>
							</div>
						</div>
						<div class="slide-citation">
							Source: https://docs.cursor.com/context/model-context-protocol
						</div>
						<aside class="notes">
							In Cursor, the Composer Agent automatically uses MCP tools listed under 'Available Tools' in the MCP settings when it determines they are relevant. You can prompt tool usage intentionally by mentioning the tool by name or description. By default, when Agent wants to use an MCP tool, it will ask for your approval, but you can enable auto-run for automatic execution.
						</aside>
					</section>
				</section>

				<!-- New Section: Cursor System Prompt -->
				<section>
					<section>
						<h2 class="bg-header">Cursor System Prompt</h2>
						<h3>Understanding Cursor's AI Foundation</h3>
						<div class="container">
							<div class="col">
								<ul>
									<li><span class="highlight">Core Identity</span>: "You are a powerful agentic AI coding assistant, powered by Claude 3.7 Sonnet"</li>
									<li><span class="highlight">Primary Goal</span>: Follow user instructions at each message</li>
									<li><span class="highlight">Tool Integration</span>: Access to file system, search and code manipulation tools</li>
									<li><span class="highlight">Context Awareness</span>: Automatically attaches information about current state</li>
									<li><span class="highlight">Proactiveness</span>: Balances task completion with user control</li>
								</ul>
							</div>
							<div class="col">
								<img src="resources/images/cursor-mode.png" alt="Cursor AI Modes">
								<p class="img-caption">Cursor operates with a sophisticated system prompt</p>
							</div>
						</div>
						<div class="slide-citation">
							Source: <a href="https://github.com/x1xhlol/system-prompts-and-models-of-ai-tools/blob/main/Cursor%20Prompts/cursor%20agent.txt" target="_blank">github.com/x1xhlol/system-prompts-and-models-of-ai-tools</a>
						</div>
						<aside class="notes">
							Cursor's power comes from its sophisticated system prompt that defines how Claude 3.7 Sonnet should behave inside the IDE. The prompt establishes the AI's identity as a coding assistant, sets rules for tool usage, and creates guidelines for how proactive the AI should be.
						</aside>
					</section>

					<section>
						<h3>Key Elements of Cursor's System Prompt</h3>
						<div class="container">
							<div class="col">
								<h4>Tool Integration Guidelines</h4>
								<ul>
									<li>Never refer to tool names when speaking to users</li>
									<li>Follow schema exactly and provide all parameters</li>
									<li>Only call necessary tools</li>
									<li>Explain intentions before calling tools</li>
								</ul>
								<h4>Code Change Rules</h4>
								<ul>
									<li>Never output code directly to users</li>
									<li>Always read file contents before editing</li>
									<li>Group edits to the same file together</li>
									<li>Limit to 3 attempts for fixing linter errors</li>
								</ul>
							</div>
							<div class="col">
								<h4>Code Format Standards</h4>
								<ul>
									<li>Create dependency files when building from scratch</li>
									<li>Never generate long hashes or binary code</li>
									<li>Fix reasonable linter errors</li>
									<li>Citation format: ```startLine:endLine:filepath```</li>
								</ul>
								<h4>Search Optimization</h4>
								<ul>
									<li>Prefer semantic search over grep/file search</li>
									<li>Read larger sections at once</li>
									<li>Stop searching once sufficient information found</li>
								</ul>
							</div>
						</div>
						<div class="slide-citation">
							Cursor's prompt encourages quality code generation while maintaining a user-friendly interface
						</div>
						<aside class="notes">
							The Cursor system prompt contains detailed guidelines on tool usage, code change procedures, format standards, and search optimization techniques. These elements work together to create a powerful yet user-friendly coding assistant that follows best practices.
						</aside>
					</section>

					<section>
						<h3>Cursor Rules</h3>
						<div class="container">
							<div class="col">
								<h4>What Are Cursor Rules?</h4>
								<ul>
									<li>Custom instructions for the AI within Cursor</li>
									<li>Override default behavior for specific use cases</li>
									<li>Can be global or project-specific</li>
									<li>Stored in <code>.cursor/rules.json</code> files</li>
								</ul>
								<h4>Rule Types</h4>
								<ul>
									<li><span class="highlight">Agent Rules</span>: Control Agent behavior</li>
									<li><span class="highlight">Chat Rules</span>: Modify chat responses</li>
									<li><span class="highlight">Tab Rules</span>: Customize autocomplete</li>
									<li><span class="highlight">Ctrl+K Rules</span>: Adjust edit behavior</li>
								</ul>
							</div>
							<div class="col">
								<pre><code class="json">
{
  "rules": [
    {
      "name": "Coding Style",
      "description": "Follow team coding conventions",
      "rule": "Always use camelCase for variables and PascalCase for classes. Add JSDoc comments to all functions.",
      "targets": ["agent", "chat"]
    },
    {
      "name": "Testing Policy",
      "description": "Ensure test coverage",
      "rule": "When creating new functions, also create a corresponding test file with at least 3 test cases.",
      "targets": ["agent"]
    }
  ]
}
</code></pre>
							</div>
						</div>
						<div class="slide-citation">
							Source: <a href="https://docs.cursor.com/context/rules" target="_blank">https://docs.cursor.com/context/rules</a>
						</div>
						<aside class="notes">
							Cursor Rules provide a way to customize how the AI assistant behaves for your specific needs. Rules can enforce coding standards, control autocomplete behavior, guide the agent on project-specific requirements, and more. They're stored in JSON format and can be applied globally or per-project.
						</aside>
					</section>

					<section>
						<h3>Implementing Cursor Rules</h3>
						<div class="container">
							<div class="col">
								<h4>Structure and Setup</h4>
								<ul>
									<li>Create <code>.cursor/rules.json</code> in project root</li>
									<li>Global rules go in <code>~/.cursor/rules.json</code></li>
									<li>Each rule needs a name, description, rule text, and targets</li>
									<li>Rules are applied in order of appearance</li>
								</ul>
								<h4>Best Practices</h4>
								<ul>
									<li>Keep rules clear and specific</li>
									<li>Target only necessary modes</li>
									<li>Use project-specific rules for unique requirements</li>
									<li>Global rules for personal preferences</li>
								</ul>
							</div>
							<div class="col">
								<img src="resources/images/cursor-interface.png" alt="Cursor interface with rules" style="box-shadow: none!important; max-height: 300px;">
								<h4>Example Use Cases</h4>
								<ul>
									<li>Enforcing team code style guidelines</li>
									<li>Project-specific architecture patterns</li>
									<li>Documentation requirements</li>
									<li>Testing policies</li>
									<li>Framework-specific best practices</li>
								</ul>
							</div>
						</div>
						<div class="slide-citation">
							Rules can significantly enhance AI collaboration by aligning with your team's standards
						</div>
						<aside class="notes">
							Implementing Cursor Rules involves creating the appropriate JSON files either at the project or global level. Well-crafted rules can significantly improve the collaboration with the AI by ensuring it follows your team's standards and best practices. This creates consistency and reduces the need for manual corrections.
						</aside>
					</section>
				</section>

				<!-- Streamlining the MCP Implementation Section -->
				<section>
					<section>
						<h2 class="bg-header">MCP Implementation Essentials</h2>
						<div class="container">
							<div class="col">
								<h4>Building Custom MCP Servers</h4>
								<ul>
									<li>Choose language - <span class="highlight">any with stdout or HTTP capabilities</span></li>
									<li>Set up transport - <span class="highlight">stdio</span> (local) or <span class="highlight">SSE</span> (network)</li>
									<li>Configure in <span class="highlight">.cursor/mcp.json</span> or <span class="highlight">~/.cursor/mcp.json</span></li>
									<li>Define capabilities via <span class="highlight">OpenAPI schema</span></li>
								</ul>
								<h4>Integration Patterns</h4>
								<ul>
									<li>Connect databases for contextual queries</li>
									<li>Link documentation systems</li>
									<li>Integrate with proprietary tools</li>
									<li>Enable web searches and API calls</li>
								</ul>
							</div>
							<div class="col">
								<pre><code class="javascript">
// Simple MCP server in Node.js
const express = require('express');
const app = express();
const port = 3000;

// Define capabilities
app.get('/capabilities', (req, res) => {
  res.json({
    name: "documentation-helper",
    description: "Accesses project documentation",
    endpoints: {
      search: {
        description: "Search docs by keyword",
        parameters: {
          query: "string"
        }
      },
      getDoc: {
        description: "Get full document by ID",
        parameters: {
          id: "string"
        }
      }
    }
  });
});

// Implement endpoints
app.get('/search', (req, res) => {
  const query = req.query.query;
  // Implementation details...
  res.json({ results: [/* search results */] });
});

app.listen(port);
</code></pre>
							</div>
						</div>
						<div class="slide-citation">
							MCP servers follow a standard protocol but can be implemented in any language
						</div>
						<aside class="notes">
							Building MCP servers is flexible - you can use any language that can write to stdout or serve HTTP endpoints. The key is defining your capabilities clearly through the OpenAPI schema and handling the necessary endpoints. This creates a standardized way for Cursor to interact with your custom tools.
						</aside>
					</section>
				</section>

				<!-- 6. Practical Applications Section - Streamlined -->
				<section>
					<h2 class="bg-header">Practical Applications</h2>
					<div class="container">
						<div class="col">
							<h4>Code Refactoring</h4>
							<ul>
								<li>Modernize legacy code patterns</li>
								<li>Convert between programming paradigms</li>
								<li>Improve readability and maintainability</li>
							</ul>
							<h4>Feature Implementation</h4>
							<ul>
								<li>Break complex tasks into logical steps</li>
								<li>Generate implementation with explanations</li>
								<li>Handle edge cases and create tests</li>
							</ul>
						</div>
						<div class="col">
							<h4>Custom MCP Integrations</h4>
							<ul>
								<li>Database integration for direct querying</li>
								<li>API/documentation connections</li>
								<li>Project-specific tools and assistants</li>
							</ul>
							<h4>Enhanced Productivity</h4>
							<ul>
								<li>Documentation generation</li>
								<li>Bug identification and fixing</li>
								<li>Code exploration and knowledge sharing</li>
							</ul>
						</div>
					</div>
					<div class="slide-citation">
						Cursor's impact is most significant when applied to real-world development challenges
					</div>
					<aside class="notes">
						The real value of Cursor and MCP becomes apparent in practical applications. Whether refactoring legacy code, implementing new features, creating custom integrations, or enhancing overall productivity, these tools can significantly accelerate development workflows and improve code quality.
					</aside>
				</section>

				<!-- 7. Discussion Section - Compact version -->
				<section>
					<h2 class="bg-header">Discussion & Key Takeaways</h2>
					<div class="container">
						<div class="col">
							<h3>Core Benefits</h3>
							<ul>
								<li><span class="highlight">Prompt Engineering</span> - Custom rules and system prompts tailor AI behavior</li>
								<li><span class="highlight">Context Protocol</span> - MCP standardizes AI-tool communication</li>
								<li><span class="highlight">Agent Capabilities</span> - End-to-end task completion with oversight</li>
								<li><span class="highlight">Extensibility</span> - Custom tools via MCP extend functionality</li>
							</ul>
						</div>
						<div class="col">
							<h3>Resources</h3>
							<ul>
								<li><a href="https://www.cursor.com/features">Cursor Features</a></li>
								<li><a href="https://docs.cursor.com/context/model-context-protocol">MCP Documentation</a></li>
								<li><a href="https://modelcontextprotocol.io/introduction">Official MCP Site</a></li>
								<li><a href="https://docs.cursor.com/context/rules">Cursor Rules</a></li>
								<li><a href="https://github.com/anthropics/anthropic-tools">MCP Examples</a></li>
							</ul>
						</div>
					</div>
					<aside class="notes">
						Cursor and MCP represent significant advancements in AI-assisted coding. By understanding and leveraging the system prompt capabilities, custom rules, and the Model Context Protocol, developers can create tailored coding experiences that significantly enhance productivity and code quality.
					</aside>
				</section>

				<!-- 8. Thank You Slide -->
				<section class="grid-slide">
					<h1 class="text-center"><strong>Thank You</strong></h1>
					<p class="text-center" style="font-size: 1em;">Questions?</p>
					<div class="citation text-center">
						<p>Key References:</p>
						<p><span class="highlight-text">Cursor</span>: AI-powered code editor with customizable prompts & rules</p>
						<p><span class="highlight-text">MCP</span>: Open protocol for standardizing AI model context</p>
					</div>
					<div class="author-info text-center" style="opacity: 0.7;">
						<p><span class="presenter-name"></span><br>
						<span class="presenter-email"></span><br>
					</div>
					<p class="text-center" style="font-size: 0.5em; margin-top: 40px; opacity: 0.7;">This presentation was created for the Special Topics in Data Science class on Prompt Engineering.</p>
					<aside class="notes">
						Thank you for attending this presentation on Cursor and the Model Context Protocol. Feel free to reach out with any questions or for further discussion on these topics.
					</aside>
				</section>
			</div>
		</div>

		<!-- Load reveal.js scripts -->
		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script src="plugin/math/math.js"></script>
		<script src="plugin/zoom/zoom.js"></script>
	</body>
</html>
